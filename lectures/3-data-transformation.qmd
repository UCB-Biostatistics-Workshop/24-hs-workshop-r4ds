---
title: Tabular Data
author: Emily Hou, Lauren Liao
format:
  revealjs:
    smaller: true
    scrollable: false
    html-math-method: mathjax
error: true
echo: true
---

## Learning Goals
- **Filter** rows of a dataset based on conditions
- **Arrange** rows of a dataset based on one or more columns
- **Select** columns of a dataset
- **Mutate** existing columns to create new columns
- use the pipe to combine multiple operations

```{r include=FALSE}
## better font size for slides
library(tidyverse)
library(knitr)
library(readr)

hook_output_default <- knitr::knit_hooks$get('output')

truncate_to_lines <- function(x, n) {
   if (!is.null(n)) {
      x = unlist(stringr::str_split(x, '\n'))
      if (length(x) > n) {
         # truncate the output
         x = c(head(x, n), '...\n')
      }
      x = paste(x, collapse = '\n') # paste first n lines together
   }
   x
}
```


## dplyr functions
This section shows the basic data frame functions in the `dplyr` package (part of `tidyverse`). The basic functions are:

- `filter()` picks out rows according to specified conditions
- `arrange()` sorts the row by values in some column(s)
- `select()` picks out columns according to their names
- `mutate()` creates new columns, often based on operations on other columns

All work similarly:

1. The first argument is a data frame.
2. The subsequent arguments describe what to do with the data frame, using the variable names (without quotes).
3. The result is a new data frame.

Together these properties make it easy to chain together multiple simple steps to achieve a complex result. 


## Sleep, Health, and Lifestyle Data
This dataset consists of collected survey results from 373 individuals. The following data points were collected for each individual:
- Identity information: gender, age, occupation
- Sleep information: sleep duration (hours), quality of sleep (scale from 1-10), sleep disorder (none, insomnia, sleep apnea)
- Other health and lifestyle information: physical activity level (minutes/day), stress level (scale 1-10), BMI category (underweight, normal, overweight), blood pressure (systolic/diastolic), heart rate (bpm), daily steps (number of steps walked per day)

- **Goal.** We will use the data here to illustrate different functions for data transformation. #needs updating


```{r, message=F}
# Read subsetted data from online file - make sure there are no spaces
# need to update
sleep = read_csv('https://bit.ly/ucb_biostat_data')

# Check number of rows
nrow(sleep)
```

# Filter rows with filter() {data-background-color=black}

## Filter rows with filter()
- `filter()` lets you filter out rows of a dataset that meet a certain condition

![](http://ohi-science.org/data-science-training/img/rstudio-cheatsheet-filter.png)

*** 
- `filter()` lets you filter out rows of a dataset that meet a certain condition
- It takes two arguments: the dataset and the condition

```{r, message=F}
filter(sleep, Sleep.Duration < 6)
```

## Comparisons
- `==` and `!=` test for equality and inequality (do not use `=` for equality)
- `>` and `<` test for greater-than and less-than
- `>=` and `<=` are greater-than-or-equal and less-than-or-equal
- these can also be used directly on vectors outside of data frames
```{r}
c(1,5,-22,4) > 0
c("a", "b", "c") == "b"
```

## Comparing to NA
- A common "gotcha" is that  `==`  cannot be used to compare to `NA`:
```{r}
x = NA
x == NA
```

- The result actually makes sense though, because I'm asking if [an unknown value] is the same as [another unknown value]. Since either side could be any value, the right answer is "I don't know".
- To check if something is `NA`, use `is.na()`
```{r}
x = NA
is.na(x)
```

## Equality on Strings
- you can use `==` to test whether a string variable matches given text
- but remember to quote the text you want to compare to
```{r}
filter(sleep, Occupation == "Teacher")
```

- why doesn't `Occupation == Teacher` work?
- why doesn't `Occupation == teacher` work?
- why doesn't `"Occupation" == "Teacher"` make sense?

## Filtering on computed values
- the condition can contain computed values

```{r, message=F}
filter(sleep, Sleep.Duration * Quality.of.Sleep > 75)
```

- note that we didn't actually do anything to the values in the data. 
- the values in the sleep duration and quality of sleep columns remain the same as before, and no new column was created either (stay tuned!)

## Exercise [together] {data-background-color=teal}

- What is the result of running this code?

```{r}
nrow(sleep)
```

```{r, eval=F}
filter(sleep, Gene == "ZZZ3")
filter(sleep, Heart <= -5)
nrow(sleep)
```


## Exercise

- Without using the internet, think of how you can use `filter` multiple times to create a dataset where blood expression is positive (>0) **and** heart expression is negative (<0)

- Using any resources you like, figure out how to use `filter` to create a dataset where **either** blood expression is positive (>0) **or** heart expression is negative (<0)

## Logical conjunctions (AND)
```{r}
filter(sleep, Blood < 0 & Heart < 0)
```

- This filters by the **conjunction** of the two constraints---both must be satisfied.
- The ampersand sign ` & ` stands for "AND"

```{r}
TRUE & FALSE
TRUE & TRUE
FALSE & TRUE
```

*** 

- For filter, you can do "AND" by passing in two separate conditions as two different arguments, but the comma and ampersand are not generally interchangeable
```{r}
# filter(sleep, Blood < 0 & Heart < 0)
filter(sleep, Blood < 0, Heart < 0)
```


## Logical conjunctions (OR)

```{r}
filter(sleep, Gene == "A2ML1" | Gene == "A4GALT")
```

- The pipe sign ` | ` stands for "OR" 
- Multiple conjunctions can describe complex logical conditions

***
```{r}
filter(sleep, Gene %in% c("ZZZ3","A2ML1")) 
# equivalent to 
# filter(sleep, Gene=="ZZZ3" | Gene=="A2ML1")
```

- ` %in% ` returns true for all elements of the thing on the left that are also elements of the thing on the right. This is actually shorthand for a match function (use `help('%in%')` to learn more)

## Negation (NOT)
```{r}
filter(sleep, !(Gene=="A2ML1"))
```
- The exclamation point ` ! ` means "NOT", which negates the logical condition
- sometimes it's easier to say what you *don't* want!

## Exercises: computed conditions, conjunctions, NAs {data-background-color=teal}

**Do each of these three exercises separately**

- Filter the sleep data to keep just the rows where the product of Blood and Heart expression is between 0 and 1.


- Excluding the gene `LAMP3`, does the individual `sleep-11TT1` have any genes with expression level greater than 4 in their blood?


- Filter out any rows where the value for `Heart` is missing (value is `NA`) 


## Sampling rows

- You can use `slice_sample()` to get `n` randomly selected rows if you don't have a particular condition you would like to filter on.

```{r}
slice_sample(sleep, n=5)
```

- the named argument `prop` allows you to sample a proportion of rows
- Do `?slice_sample()` to see how you can sample with replacement or with weights

## Filtering by row number

- Data frames typically don't have a `row_number` column that you can reference, but you can invisibly create one for filter to operate on with  `row_number()` 
- This is more useful once you have sorted the data in a particular order, which we will soon see how to do.

```{r}
filter(sleep, row_number()<=3)
```

# Sort rows with arrange() {data-background-color=black}

## Sort rows with arrange()

- `arrange()` takes a data frame and a column, and sorts the rows by the values in that column (ascending order).

![](https://rstudio-education.github.io/tidyverse-cookbook/images/dplyr-arrange.png)

***
- `arrange()` takes a data frame and a column, and sorts the rows by the values in that column (ascending order).
- Again, the first argument is the data frame and the other arguments tell the function what to do with it
```{r}
arrange(sleep, Blood)
```

## Descending sort
- Use the desc function to arrange by descending values
```{r}
arrange(sleep, desc(Blood))
```

## Multisort

- This is useful if there is a tie in sorting by the first column.

```{r}
arrange(sleep, Gene, Blood)
```


## Exercise: top 5 high expression instances {data-background-color=teal}

Use `arrange()` and `filter()` to get the data for the 5 rows with the highest expression values in blood

# Piping {data-background-color=black}

## Nesting and Temporary Variables

- In our last exercise, we used two function applications to arrive at our answer. Shown below, we used temporary variables to keep our code clean. 
```{r}
sleep_by_blood = arrange(sleep, desc(Blood)) # using a temporary variable
filter(sleep_by_blood, row_number()<=5)
```

- we can also accompish this by "nesting" the function calls:
```{r}
filter(arrange(sleep, desc(Blood)), row_number()<=5) # "nesting" the calls to filter and arrange
```

- Which do you prefer? Why? What are the sylistic pros and cons to both if you are trying to understand what the code does for the first time?

## The pipe

- R solves these problems with the "pipe" operator `|>`

```{r, eval=F, tidy=F}
sleep |> 
  arrange(desc(Blood)) |>
  filter(row_number()<=5)
```

. . . 

- How does this compare with our code before? What do you notice?

```{r, eval=F, tidy=F}
sleep_by_blood = arrange(sleep, desc(Blood)) # using a temporary variable
filter(sleep_by_blood, row_number()<=5)
```


## Pipe syntax

When `df1` is piped into `fun(x)` (`fun` is just some fake function)

```{r eval=FALSE}
df1 |> fun(x)
```

is converted into:

```{r eval=FALSE}
fun(df1, x)
```

- That is: the thing being piped in is used as the _first_ argument of `fun`.
- The tidyverse functions are consistently designed so that the first argument is a data frame, and the result is a data frame, so you can push a dataframe all the way through a series of functions

*** 

- The pipe represents a "conveyor belt" along which data is passed from function to function ("workers") in an assembly line

```{r, eval=F, tidy=F}
sleep |> 
  arrange(desc(Blood)) |>
  filter(row_number()<=5)

# same as:
#   arrange(sleep, desc(Blood)) |>
#   filter(row_number()<=5)


# same as:
#   filter( arrange(sleep, desc(Blood)), row_number()<=5)
```

*** 
- The pipe works for all variables and functions (not just tidyverse functions)

Piping a string
```{r}
# paste("hello", "world")
"hello" |> paste("world") 
```

Piping a vector

```{r}
# sum(c(1,44,21,0,-4))
c(1,44,21,0,-4) |> sum()
```

Piping a data frame

```{r, max.lines=5}
# filter(sleep, Gene=="ZZZ3")
sleep |> filter(Gene=="ZZZ3") 
```


## Two Pipes

**History**
- R had no pipe
- ~2014: introduced by `magrittr` package (as `%>%`)
- ~2016: tidyverse adoption, proliferated in code
- ~2021: base language adopted idea, implemented native pipe `|>`


- `%>%` and `|>` are (basically) the same
- you will see both in the wild


```{r, max.lines=5, eval=F}
filter(sleep, Gene=="ZZZ3")
sleep |> filter(Gene=="ZZZ3") 
sleep %>% filter(Gene=="ZZZ3") 
```

## Exercise: Pipe to ggplot {data-background-color=teal}

- Run this code to see what it does. Then rewrite it using the pipe operator (get rid of the intermediate variables `mybl2` and `outliers`) and get it to produce the same output.

```{r, eval=F, tidy=F}
mybl2 = filter(sleep, Gene == 'MYBL2')

# we haven't learned about this function yet, but doesn't matter
outliers = mutate(mybl2, blood_outlier = abs(Blood) > 2) 

ggplot(outliers) +
  geom_bar(aes(x=blood_outlier))
```


# Select columns with select() {data-background-color=black}

## Select columns with select()
- The select function will return a subset of the tibble, using only the requested columns in the order specified.

![](http://ohi-science.org/data-science-training/img/rstudio-cheatsheet-select.png)

***
- The select function will return a subset of the tibble, using only the requested columns in the order specified.
- first argument is a data frame, then columns you want to select

```{r}
sleep |>
  select(Gene, Ind, expression=Blood)
```

- you can rename columns in the result with the syntax ` new_name = old_name`

## Helpers
- `select()` can also be used with handy helpers like `starts_with()` and `contains()`

```{r}
sleep |>
  select(starts_with("L"))
```
- Use `?select` to see all the possibilities

***

```{r}
sleep |>
  select(contains("N"))
```
- The quotes around the letter `"N"` make it a string. If we did not do this, `R` would think it was looking for a variable called `N` and not just the plain letter.
- We don't have to quote the names of columns (like `Ind`) because the `tidyverse` functions know that we are working within the dataframe and thus treat the column names like they are variables in their own right

***

- we can even select columns based on metadata (but not values!)

```{r}
sleep |>
  select(where(is.numeric))
```


## Negation

- `select()` can also be used to select everything **except for** certain columns
```{r}
sleep |>
  select(-starts_with("L"), -Ind)
```


## Exercise: select and filter {data-background-color=teal}

A colleague wants to see the blood expression for the gene A2ML1 for each person. Use select and filter to produce a dataframe for her that has just two columns: `individual` and `expression`, where the expression values are the blood expression values for each person for the gene A2ML1.

Before writing any code, break the problem down conceptually into steps. Figure out how to do each step independently before you put them together.

## pull() 
- `select()` has a friend called `pull()` which returns a vector instead of a (one-column) data frame

![](https://www.gastonsanchez.com/intro2cwd/images/eda/dplyr-extract-column.svg)

*** 
::::{.columns}
:::{.column}
```{r max.lines = 3}
# same as sleep$Gene, but pipeable!
# eg. sleep |> .... |> pull(some_col) 
sleep |> pull(Gene)
```

:::
:::{.column}
```{r}
sleep |> select(Gene)
```

:::
::::

## Rename columns
::::{.columns}
:::{.column}
- `select()` can be used to rename variables, but it drops all variables not selected
```{r max.lines = 6}
sleep |> select(individual = Ind)
```

:::
:::{.column}
- `rename()` is better suited for this because it keeps all the columns
```{r max.lines = 6}
sleep |> rename(individual = Ind)
```

:::
::::


# Add new variables with mutate() {data-background-color=black}

## Add new variables with mutate()
- `mutate` creates new columns

![](https://ohi-science.org/data-science-training/img/rstudio-cheatsheet-mutate.png)

***
- `mutate` creates new columns
- first argument is a dataframe, second specifies what you want the new columns to be
```{r, max.lines = 5}
sleep |>
  mutate(scaled_blood = 100*Blood))
```
- This uses `mutate()` to add a new column to which is the absolute value of `Blood`.
- The thing on the left of the `=` is a new name that you make up which you would like the new column to be called
- The expression on the right of the `=` defines what will go into the new column

***
- **Warning!** If the new variable name already exists, `mutate()` will overwrite the existing one (*in the new dataframe that gets created*)
```{r, max.lines = 5}
sleep |>
  mutate(Blood = 100*Blood)
```

***
- `mutate()` can create multiple columns at the same time and use multiple columns to define a single new one

```{r, tidy=F}
sleep |>
  mutate(  # the newlines make it more readable
      scaled_blood = 100* Blood,
      scaled_heart = 100* Heart,
      scaled_blood_heart_dif = scaled_blood - scaled_heart
  )
```
- Note that we have also used two columns simultaneously to create a new column


***
- mutate is used for text data too
```{r, max.lines = 5}
library(stringr)

sleep |>
  mutate(Ind_ID_suffix = str_extract(Ind, "(sleep-)(.*)", group=2)) |>
  select(Ind, Ind_ID_suffix)
```


## Type conversion
- Data is sometimes given to you in a form that makes it difficult to do operations on
```{r}
df = tibble(number = c("1", "2", "3"))
df
df |> mutate(number_plus_1 = number + 1)
```

- `mutate()` is also useful for converting data types, in this case text to numbers
```{r}
df |> mutate(number = as.numeric(number))
```

## Indicators

::::{.columns}
:::{.column}
- `mutate()` can be used to make logical columns (indicators)
```{r, tidy=F}
sleep |>
  mutate(positive_liver = Liver > 0) |>
  select(Gene, Ind, Liver, positive_liver)
```

:::
:::{.column}
- which can be used to make plots
```{r, tidy=F}
sleep |>
  mutate(positive_liver = Liver > 0) |>
ggplot(aes(x=positive_liver, y=Blood)) +
  geom_violin()
```

:::
::::

***
or you can just "mutate" directly in ggplot!
```{r, tidy=F}
sleep |>  # mutate(positive_liver = Liver > 0) |>
ggplot(aes(x=Liver > 0, y=Blood)) +
  geom_violin()
```

## Exercise: mutate() {data-background-color=teal}

*Before writing code for each problem , break the problem into steps. Do you have to create new columns? Filter rows? Arrange rows? Select columns? In what order? Once you have a plan, write code, one step at a time.*


**Problem 1** 

I want to see if certain genes are generally more highly expressed in certain individuals, irrespective of tissue type. Using the sleep data, create a new column containing the sum of the four expression measurements in the different tissues.

**Problem 2** 

Produce a plot showing blood vs heart expression of the MYL1 gene only and assign color based on positive vs. negative expression of that gene in liver tissue.

**Problem 3** 

Produce a vector containing the ten individual IDs (`Ind`) with the biggest difference in their heart and lung expression for the A2ML1 gene.



## mutate() and if_else()
- `if_else` is a vectorized if-else statement
- the first argument is an R expression that evaluates to a logical vector, the second argument is what to replace all of the resulting TRUEs with, and the third argument is what to replace the resulting FALSEs with
```{r}
x = c(-1, 1/2, 2/3, 5)
if_else(0<=x & x<=1, "in [0,1]", "not in [0,1]")
```
- this is often used in `mutate()`:
```{r, max.lines=10}
sleep |>
mutate( 
  blood_expression = ifelse(
    Blood < 0, "-", "+"
))
```

***
- this is useful to "interleave" columns:
```{r, echo=F}
emails = tibble(
  name = c('aya', 'bilal', 'chris', 'diego'),
  school = c('aya@amherst.edu', 'bilal@berkeley.edu', 'chris@cornell.edu', 'diego@duke.edu'),
  personal = c('aya@aol.com', 'bilal@bellsouth.net', 'chris@comcast.com', 'diego@dodo.com.au'),
  preferred = c('school', 'personal', 'personal', 'school')
)
emails
```

```{r}
emails |> 
mutate(preferred_email = ifelse(preferred=='personal', personal, school))
```
