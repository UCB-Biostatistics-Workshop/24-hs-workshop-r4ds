---
title: R Programming
author: Alejandro Schuler
format:
  revealjs:
    smaller: true
    scrollable: false
    html-math-method: mathjax
error: true
echo: true
---

## Learning Goals:

- save values to variables
- find and call R functions with multiple arguments by position and name
- recognize and index vectors and lists
- recognize, import, and inspect data frames
- issue commands to R using the Rstudio script pane

## Programming Basics
- We've seen code like
```{r, echo=F, message=F, warning=F}
library(tidyverse)
```
```{r, eval=F}
genes = read_csv("https://tinyurl.com/cjkuecnc")
```
```{r, include=F}
genes = read_csv("https://tinyurl.com/cjkuecnc")
```

- We know this reads a .csv from a file and creates something called a "data frame" 
- We've been using this data frame in code like
```{r, eval=F}
ggplot(genes) + 
  geom_bar(aes(x = ancestry, fill = phenotype))
```

- But what does this syntax really mean? Is it useful outside of making plots?

# Assignment {data-background-color=black}

## Assignment

- To do complex computations, we need to be able to give
names to things.
```{r, eval=F}
genes = read_csv("https://tinyurl.com/cjkuecnc")
```

- This code *assigns* the result of running `read_csv("https://tinyurl.com/cjkuecnc")` to the name `gene`
- You can do this with any values and/or functions

:::: {.columns}
:::{.column}
```{r}
x = 1
```

- R prints no result from this assignment, but what you entered
causes a side effect: R has stored the association between
x and the result of this expression (look at the Environment pane.)
:::
:::{.column}
![](https://github.com/alejandroschuler/r4ds-courses/blob/summer-2023/figures/x_gets_1.png?raw=true)
:::
::::

## Variables

```{r}
x
x / 5
```
- When R sees the name of a variable, it uses the stored value of
that variable in the calculation.
- We can break complex calculations into named parts. This is a
simple, but very useful kind of abstraction.

![](https://github.com/alejandroschuler/r4ds-courses/blob/summer-2023/figures/x_is_1.jpg?raw=true)

## Two ways to assign

In R, there are (unfortunately) two assignment operators. They have
subtly different meanings (more details later).

- `<-` requires that you type two characters but better captures spirit of assignmnet
- `=` is easier to type but incorrectly suggests mathematical equality
- You will see both used throughout R and user code.

```{r}
x <- 10
x
x = 20
x
```

## Assignment has no undo
```{r}
x = 10
x
x = x + 1
x
```

- If you assign to a name with an existing value, that value is overwritten.
- There is no way to undo an assignment, so be careful in reusing variable names.

## Naming variables
- It is important to pick meaningful variable names.
- Names can be too short, so don't use `x` and `y` everywhere.
- Names can be too long (`Main.database.first.object.header.length`).
- Avoid silly names.
- Pick names that will make sense to someone else (including the
person you will be in six months).
- ADVANCED: See `?make.names` for the complete rules on
what can be a name.

***
There are different conventions for constructing compound names. Warning:
disputes over the right way to do this can get heated.
```{r, prompt=FALSE,eval=FALSE,tidy=FALSE}
stringlength
string.length
StringLength
stringLength
string_length (underbar)
string-length (hyphen)
```

- To be consistent with the packages we will use, I recommend snake_case where you separate lowercase words with _
- Note that R itself uses several of these conventions.
- One of these won't work. Which one and why?

***
```{r, eval=F}
a = 1
A # this causes an error because A does not have a value
```
```
Error: object 'A' not found
```
- R cares about upper and lower case in names.
- names can't start with numbers

```{r eval=FALSE}
for = 7 # this causes an error
```

- `for` is a reserved word in R. (It is used in loop control.)
- ADVANCED: see `?Reserved` for the complete rules.

## Exercise: birth year {data-background-color=teal}

- Make a variable that represents the age you will be at the end of this year
- Make a variable that represents the current year
- Use them to compute the year of your birth and save that as a variable
- Print the value of that variable

## Assignment and Reference
```{r}
x = 2
y = x
y
x = 1
y
```

- What do you observe?

***
```{r}
x = 2
y = x
y
x = 1
y
```

::::{.columns}
:::{.column}
![](https://github.com/alejandroschuler/r4ds-courses/blob/summer-2023/figures/y_gets_x.png?raw=true)
:::
:::{.column}
![](https://github.com/alejandroschuler/r4ds-courses/blob/summer-2023/figures/x_changes.png?raw=true)
:::
::::


# Functions {data-background-color=black}

## Calling functions
- To call a function, type the function name, then the argument or
arguments in parentheses. (Use a comma to separate the arguments, if
                           more than one.)
```{r}
sqrt(2)
```


## Arguments

- Functions transform inputs to outputs
- internally, however, they have an environment just like the one you see in your workspace
- when you call a function, you tell it how to connect the variables in your environment to the ones it expects to have so that it can do its job
- the names the function calls these inputs inside itself will be different than what you call them on the outside

```
aes(x=EIF3L, y=VAPA)
```

![](https://github.com/alejandroschuler/r4ds-courses/blob/summer-2023/figures/call.png?raw=true)


## Named and positional arguments

::::{.columns}
:::{.column}

- Arguments can be supplied **by name** using the syntax
variable `=` value.
- you can see the names of the arguments in the help page for each function
- When using names, the order of the named arguments
does not matter.
```{r, tidy=F}
ggplot(data=genes) + 
  geom_point(mapping=aes(y=EIF3L, x=VAPA))
```

:::
:::{.column}

- If you leave the names off, R defaults to a **positional** order that is specific to each function (e.g. for `aes()`, `x` comes first, then `y`)
- you can see the default order of the arguments in the help page for each function
```{r, tidy=F} 
ggplot(genes) + 
  geom_point(aes(VAPA, EIF3L))
```

:::
::::

## Optional arguments
- Many R functions have arguments that you don't always have to specify. For example:
```{r setup, eval=FALSE}
file_name = "https://tinyurl.com/cjkuecnc"
genes_10 = read_csv(file_name, n_max=10) # only read in 10 rows
genes = read_csv(file_name) 
```
- `n_max` tells `read_csv()` to only read the first 10 rows of the dataset. 
- If you don't specify it, it defaults to infinity (i.e. R reads until there are no more lines in the file).

## Exercise [together] {data-background-color=teal}

Why does this code generate errors?

```{r, tidy=F}
ggplot(the_data=genes) + 
  geom_point(mapping=aes(y_axis=EIF3L, x_axis=VAPA))
```

## Exercise [together] {data-background-color=teal}

::::{.columns}
:::{.column}
I'm trying to generate this plot:

```{r, echo=F, tidy=F}
ggplot(data=genes) + 
  geom_point(aes(EIF3L, VAPA))
```
:::
:::{.column}
But when I use this code, I get:

```{r, tidy=F}
ggplot(data=genes) + 
  geom_point(aes(VAPA, EIF3L))
```

What am I doing wrong?
:::
::::

## Functions, assignment, and reference
```{r}
x = 2
x^2
x
```

- What do you observe?

***
```{r}
x = 2
x^2
x
```

![](https://github.com/alejandroschuler/r4ds-courses/blob/summer-2023/figures/x_squared.png?raw=true)

- functions generally do not affect the variables you pass to them (`x` remains the same after `sqrt(x)`)

# Vectors {data-background-color=black}

## Repetitive calculations
```{r}
x1 = 1
x2 = 2
x3 = 3
```

Let's say I have these variables and I want to add 1 to all of them and save the result.

```{r}
y1 = 1 + x1
y2 = 1 + x2
y3 = 1 + x3
```

This does the trick but it's a lot of copy-paste

## Vectors

- Vectors solve the problem
```{r}
x = c(1,2,3)
y = x + 1
y
```

- A vector is a one-dimensional sequence of zero or more values
- Vectors are created by wrapping the values separated by commas with the `c(` `)` function, which is short for "combine"
- Many R functions and operators (like `+`) automatically work with
multi-element vector arguments.

## Elementwise operations

- This multiplies each element of `c(1,2,3)` by the corresponding element of `c(4,5,6)`
```{r}
c(1,2,3) * c(4,5,6)
```

- Many basic R functions operate on multi-element vectors as
easily as on vectors containing a single number.
```{r}
sqrt(c(1,2,3))
c(1,2,3)^3
log(c(1,2,3))
```

## Summaries

- some R functions take vectors as arguments and summarize them instead of applying elementwise
```{r}
numbers <- c(9, 12, 6, 10, 10, 16, 8, 4)
numbers
sum(numbers)
sum(numbers)/length(numbers)
mean(numbers)
```


## Exercise: subtract the mean {data-background-color=teal}

```{r}
x = c(7, 3, 1, 9)
```
- Subtract the mean of `x` from `x`, and then `sum` the result (it should be 0!)

## Exercise: a vector of variables [together]  {data-background-color=teal}

- Predict the output of the following code:
```{r, eval=F}
a = 1
b = 2
x = c(a,b)

a = 3
print(x)
```

## Ranges
```{r}
1:50
```

- The colon `:` is a handy shortcut to create a vector that is
a sequence of integers from the first number to the second number
(inclusive).
- Ranges can go the other way too and include negative numbers, e.g. `5:-5`
- Long vectors wrap around. (Your screen may have a different width than what is shown here.)

## Indexing

```{r}
x
x[1] # same as x[c(1)] since 1 is already a vector (of length 1)
x[2:4]
x[c(3, 1)]
x[c(1,1,1,1,1,1,4)]
```

- Indexing returns a subsequence of the vector. It does not change
the original vector. Assign the result to a new variable to save it if you neeed it later.
- R starts counting vector indices from 1.
- You can index using a multi-element index vector.
- You can repeat index positions

## Exercise: reading vector code {data-background-color=teal}

What does this code do?
```{r, eval=F}
x = ... # some vector
x[length(x):1]
```

Hints:
- assign `x` some values and try it to see!
- read inside out: first figure out what `length(x)` does, then think about what the output of `length(x):1` should do, and then finally `x[length(x):1]`

## Indexed Assignment

- you can assign _into_ an indexed position

```{r}
x
x[1] = 100
x
```

- or multiple

```{r}
x
x[c(1,2)] = c(100, 200)
x
x[c(1,2)] = -1
x
```

# Data Types  {data-background-color=black}

## Strings

- text data in R is called a "string"
```{r}
my_string = "hello"
```
- when using data that is text in R, you have to refer to it using quotation marks (why?)
```{r, eval=F}
my_string = hello # what does this code do?
```
- you can have a vector of strings, and functions can operate on these too:
```{r}
words = c("hello", "how", "are", "you", "?")
paste(words, collapse=" ")
```

## Factors
```{r}
library(forcats)
```

- factors represent categorical data
```{r}
seasons_str = c("spring", "summer", "fall", "winter") # string vector
seasons_str
```
```{r}
seasons_fct = fct(seasons_str) # factor vector
seasons_fct
```

- this is useful to tightly control data and prevent accidents
```{r}
seasons_str[1] = "Jan"
```
```{r}
seasons_fct[1] = "Jan"
```

## Logicals
```{r}
c(-2, -1, 0, 1, 2) > 0
c(TRUE, TRUE, FALSE)
```

- logical vectors can only be `TRUE` or `FALSE`
- we'll see more about this later

## Coercion
- If you try to do something to a vector of the wrong data type, R will often do its best to "make it work" by converting to another type
```{r}
TRUE + 2
```

```{r}
numbers = c(1,2,3)
numbers[1] = '5'
numbers + 2
```

- this is a frequent source of unexpected errors!

## Exercise: data types [together]  {data-background-color=teal}

What types are each of the following vectors? Are they all fundamentally the same, or are they different?

```{r, eval=F}
v1 = c(0,1)
v2 = c(FALSE, TRUE)
v3 = c("FALSE", "TRUE")
v4 = fct(v3)
```

Which of these lines of code will run and which will produce an error?
```{r, eval=F}
v1 + 1
v2 + 1
v3 + 1
v4 + 1
```

## NA
- R has a special value that represents missing data- it's called `NA`
```{r}
c(1,2,NA,4)
```
- NA can appear anywhere that R would expect some other kind of data
- NA usually ruins computations:
```{r}
1 + NA + 3
```
- The result makes sense because if I don't know what I'm adding together, I don't know the result either
- some functions have options to ignore the missing values in vectors:
```{r}
mean(c(1,2,NA,4), na.rm=TRUE)
```

# Lists  {data-background-color=black}

## Lists

- A `list` is like an atomic vector, except the elements don't have to be the same type of thing
```{r}
a_vector = c(1,2,4,5)
maybe_a_vector = c(1,2,"hello",5,TRUE)
maybe_a_vector # R converted all of these things to strings!
```
- You make them with list() and you can index them like vectors
```{r}
a_list = list(1,2,"hello",5,TRUE)
a_list[3:5]
```

- Anything can go in lists, including vectors, other lists, data frames, etc.
- In fact, a data frame (or tibble) is actually just a list of named column vectors with an enforced constraint that all of the vectors have to be of the same length. That's why the `df$col` syntax works for data frames.

## Getting elements from a list

- You can also name the elements in a list
```{r}
a_list = list(
    first_number = 1,
    second_number = 2,
    a_string = "hello",
    third_number = 5,
    some_logical = TRUE)
```
- and then retrieve elements by name or position 
```{r}
# returns the element named "thrid_number"
a_list$a_string  
a_list[['a_string']]

# returns the 3rd element
a_list[[3]]

# subsets the list, so returns a list of length 1 that contains a single element (the third)
a_list[3]
```

## Examining lists

- Use `str()` to dig into nested lists and other complicated objects
```{r}
nested_list = lm(hp ~ ., mtcars)
str(nested_list)
```


# Data Frames {data-background-color=black}

## Making data frames
- use `tibble()` to make your own data frames from scratch in R
```{r, tidy=F}
my_data = tibble(
  person = c("carlos", "nathalie", "christina", "alejandro"),
  age = c(33, 48, 8, 29)
)
my_data
```

## Data frame properties
- `dim()` gives the dimensions of the data frame. `ncol()` and `nrow()` give you the number of columns and the number of rows, respectively.
```{r}
dim(my_data)
ncol(my_data)
nrow(my_data)
```

- `names()` gives you the names of the columns (a vector)
```{r}
names(my_data)
```

***
- `glimpse()` shows you a lot of information, `head()` returns the first `n` rows
```{r}
glimpse(my_data)

head(my_data, n=2)
```

## Writing data frames
```{r, eval=F}
write_csv(my_data, "~/Desktop/my_data.csv")
```
- after running this, you'll see a new file called `my_data.csv` (or whatever you chose to name it) appear in the specified location on your computer (e.g. `Desktop`)
- you can read and write `.csv` files in lots of programs (e.g. google sheets)
- to read and write other formats look at documentation and use google + chatGPT!

# Scripts  {data-background-color=black}

## Using the script pane

::::{.columns}
:::{.column}
- Writing a series of expressions in the console rapidly gets
messy and confusing.
- The console window gets reset when you restart RStudio.
- It is better (and easier) to write expressions and functions
in the script pane (upper left), building up your analysis.
- There, you can enter expressions, evaluate them, and save the
contents to a .R file for later use.
- Look at the RStudio ``Code'' menu for some useful keyboard
commands.
:::
:::{.column}
- Create a script pane: File > New File > R Script
- Put your cursor in the script pane.
- Type: `1:10^2`
- Then hit `Command-RETURN` (Mac), or `Ctrl-ENTER` (Windows).
- That line is copied to the console pane and evaluated.
- You can save the script to a file.
- Explore the RStudio Code menu for other commands.
:::
::::

## Comments
```{r}
## In this section, we make a vector and reverse its order
x = 1:3 * 10                # make a vector [10, 20 ... ]
x_reversed = x[length(x):1] # reverse its order
```
- Use a `#` to start a comment.
- A comment extends to the end of the
line and is ignored by R.
- comments are complemented by good code style!


## RStudio Pro-tip: scrolling and multicursors

- You should also be aware of `cmd-<arrow>` and `alt-<arrow>` for moving the cursor (by line and by word)
- and `cmd-shift-<arrow>` and `alt-shift-<arrow>` for selecting text (by line and by word)
- these also combo with shift (to select) and delete
- RStudio's script pane supports multi-cursors! Hold `alt` and drag your mouse up and down 
- You can also set a keyboard shortcut for `find and add next`
- These features make it much easier to rename variables, etc.

## Exercise: Plotting a parabola  {data-background-color=teal}

::::{.columns}
:::{.column}
Write an R script that starts with:

```{r}
A = 1
B = 2
C = 3
```

In the rest of the script, do the following:

- generate an evenly-spaced sequence of 100 values between -5 and 5 (find an R function that does this). Call this `x`
- generate the corresponding y-values `y` by computing the formula y = Ax^2 + Bx + C
- create a data frame with `x` and `y` as columns
- use ggplot to create a line plot of `x` vs `y`

Run your script to see the generated plot. Try changing the values of `A`, `B`, and `C` at the top of the script and re-running to see how the plot changes.
:::
:::{.column}

Your result should look like:

```{r, echo=F}
x = seq(-5, 5, length.out=100)
y = A*x^2 + B*x + C
df = tibble(x=x, y=y)
ggplot(df) + geom_line(aes(x,y))
```

:::
::::